
package com.gos.rebuilt.choreo_gen;

import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import java.util.Map;
import java.util.OptionalInt;

// If these imports cause errors because you're not using ChoreoLib,
// turn off "Include ChoreoLib-specific Helpers" in Choreo's codegen settings.
import choreo.auto.AutoRoutine;
import choreo.auto.AutoTrajectory;

/**
 * A class containing the name, start pose, end pose, and total time of every Choreo trajectory.
 * This prevents your code from referencing deleted or misspelled trajectories,
 * and removes the need for JSON parsing to load a trajectory's essential data.
 * DO NOT MODIFY THIS FILE YOURSELF! It is automatically generated by Choreo.
 */
public record ChoreoTraj(
    String name,
    OptionalInt segment,
    double totalTimeSecs,
    Pose2d initialPoseBlue,
    Pose2d endPoseBlue
) {
    public static final ChoreoTraj NormalPath_MaxAccelMaxSpeed = new ChoreoTraj(
	    "NormalPath_MaxAccelMaxSpeed",
	    OptionalInt.empty(),
	    1.81238,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj RotatedPath_MaxAccel12rps = new ChoreoTraj(
	    "RotatedPath_MaxAccel12rps",
	    OptionalInt.empty(),
	    2.07532,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj RotatedPath_MaxAccel1rps = new ChoreoTraj(
	    "RotatedPath_MaxAccel1rps",
	    OptionalInt.empty(),
	    6.26284,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(-0.048))
	);
	public static final ChoreoTraj RotatedPath_MaxAccel2rps = new ChoreoTraj(
	    "RotatedPath_MaxAccel2rps",
	    OptionalInt.empty(),
	    3.19437,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj RotatedPath_MaxAccel4rps = new ChoreoTraj(
	    "RotatedPath_MaxAccel4rps",
	    OptionalInt.empty(),
	    2.11779,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj RotatedPath_MaxAccel8rps = new ChoreoTraj(
	    "RotatedPath_MaxAccel8rps",
	    OptionalInt.empty(),
	    2.07536,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj RotStrPath_MaxAccel15rps = new ChoreoTraj(
	    "RotStrPath_MaxAccel15rps",
	    OptionalInt.empty(),
	    2.07384,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(-0.048))
	);
	public static final ChoreoTraj RotStrPath_MaxAccel1rps = new ChoreoTraj(
	    "RotStrPath_MaxAccel1rps",
	    OptionalInt.empty(),
	    6.31865,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(-0.048))
	);
	public static final ChoreoTraj RotStrPath_MaxAccel5rps = new ChoreoTraj(
	    "RotStrPath_MaxAccel5rps",
	    OptionalInt.empty(),
	    4.1731,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(-0.048))
	);
	public static final ChoreoTraj StraightPathNAV_MaxAccel10fps = new ChoreoTraj(
	    "StraightPathNAV_MaxAccel10fps",
	    OptionalInt.empty(),
	    2.34043,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj StraightPathNAV_MaxAccel15fps = new ChoreoTraj(
	    "StraightPathNAV_MaxAccel15fps",
	    OptionalInt.empty(),
	    2.07657,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj StraightPathNAV_MaxAccel1fps = new ChoreoTraj(
	    "StraightPathNAV_MaxAccel1fps",
	    OptionalInt.empty(),
	    20.05922,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj StraightPathNAV_MaxAccel5fps = new ChoreoTraj(
	    "StraightPathNAV_MaxAccel5fps",
	    OptionalInt.empty(),
	    4.17315,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj StraightPath_MaxAccel10fps = new ChoreoTraj(
	    "StraightPath_MaxAccel10fps",
	    OptionalInt.empty(),
	    2.33971,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj StraightPath_MaxAccel1fps = new ChoreoTraj(
	    "StraightPath_MaxAccel1fps",
	    OptionalInt.empty(),
	    20.054,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj StraightPath_MaxAccel5fps = new ChoreoTraj(
	    "StraightPath_MaxAccel5fps",
	    OptionalInt.empty(),
	    4.17334,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);

    /**
     * A map between trajectory names and their corresponding data.
     * This allows for trajectory data to be looked up with strings during runtime.
     */
    public static final Map<String, ChoreoTraj> ALL_TRAJECTORIES = Map.ofEntries(
    	Map.entry("NormalPath_MaxAccelMaxSpeed", NormalPath_MaxAccelMaxSpeed),
		Map.entry("RotatedPath_MaxAccel12rps", RotatedPath_MaxAccel12rps),
		Map.entry("RotatedPath_MaxAccel1rps", RotatedPath_MaxAccel1rps),
		Map.entry("RotatedPath_MaxAccel2rps", RotatedPath_MaxAccel2rps),
		Map.entry("RotatedPath_MaxAccel4rps", RotatedPath_MaxAccel4rps),
		Map.entry("RotatedPath_MaxAccel8rps", RotatedPath_MaxAccel8rps),
		Map.entry("RotStrPath_MaxAccel15rps", RotStrPath_MaxAccel15rps),
		Map.entry("RotStrPath_MaxAccel1rps", RotStrPath_MaxAccel1rps),
		Map.entry("RotStrPath_MaxAccel5rps", RotStrPath_MaxAccel5rps),
		Map.entry("StraightPathNAV_MaxAccel10fps", StraightPathNAV_MaxAccel10fps),
		Map.entry("StraightPathNAV_MaxAccel15fps", StraightPathNAV_MaxAccel15fps),
		Map.entry("StraightPathNAV_MaxAccel1fps", StraightPathNAV_MaxAccel1fps),
		Map.entry("StraightPathNAV_MaxAccel5fps", StraightPathNAV_MaxAccel5fps),
		Map.entry("StraightPath_MaxAccel10fps", StraightPath_MaxAccel10fps),
		Map.entry("StraightPath_MaxAccel1fps", StraightPath_MaxAccel1fps),
		Map.entry("StraightPath_MaxAccel5fps", StraightPath_MaxAccel5fps)
    );

    /**
     * Looks up the ChoreoTraj segment of the given overall ChoreoTraj.
     * WARNING: will raise an exception if not called with a valid segment index.
     */
    public ChoreoTraj segment(int segment) {
        var traj = ChoreoTraj.ALL_TRAJECTORIES.get(this.name + "$" + segment);
        if (traj == null) {
            throw new NullPointerException("Trajectory " + this.name + " does not have segment #" + segment + ".");
        }
        return traj;
    }
    
    // If these methods cause errors because you're not using ChoreoLib,
    // turn off "Include ChoreoLib-specific Helpers" in Choreo's codegen settings.
    /**
     * Load an AutoTrajectory directly from a ChoreoTraj, which may be a segment of a larger trajectory.
     */
    public AutoTrajectory asAutoTraj(AutoRoutine routine) {
        if (this.segment.isPresent()) {
            return routine.trajectory(this.name, this.segment.getAsInt());
        }
        return routine.trajectory(this.name);
    }
}
