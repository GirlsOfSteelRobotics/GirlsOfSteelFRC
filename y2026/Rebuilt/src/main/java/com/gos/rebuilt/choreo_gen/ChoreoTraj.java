
package com.gos.rebuilt.choreo_gen;

import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import java.util.Map;
import java.util.OptionalInt;

// If these imports cause errors because you're not using ChoreoLib,
// turn off "Include ChoreoLib-specific Helpers" in Choreo's codegen settings.
import choreo.auto.AutoRoutine;
import choreo.auto.AutoTrajectory;

/**
 * A class containing the name, start pose, end pose, and total time of every Choreo trajectory.
 * This prevents your code from referencing deleted or misspelled trajectories,
 * and removes the need for JSON parsing to load a trajectory's essential data.
 * DO NOT MODIFY THIS FILE YOURSELF! It is automatically generated by Choreo.
 */
public record ChoreoTraj(
    String name,
    OptionalInt segment,
    double totalTimeSecs,
    Pose2d initialPoseBlue,
    Pose2d endPoseBlue
) {
    public static final ChoreoTraj StartLeftDepot = new ChoreoTraj(
	    "StartLeftDepot",
	    OptionalInt.empty(),
	    3.57649,
	    new Pose2d(3.564, 7.665, Rotation2d.fromRadians(3.138)),
	    new Pose2d(2.523, 6.373, Rotation2d.fromRadians(2.335))
	);
	public static final ChoreoTraj StartLeftDepot$0 = new ChoreoTraj(
	    "StartLeftDepot",
	    OptionalInt.of(0),
	    2.27705,
	    new Pose2d(3.564, 7.665, Rotation2d.fromRadians(3.138)),
	    new Pose2d(0.858, 5.945, Rotation2d.fromRadians(3.142))
	);
	public static final ChoreoTraj StartLeftDepot$1 = new ChoreoTraj(
	    "StartLeftDepot",
	    OptionalInt.of(1),
	    1.2994400000000002,
	    new Pose2d(0.858, 5.945, Rotation2d.fromRadians(3.142)),
	    new Pose2d(2.523, 6.373, Rotation2d.fromRadians(2.335))
	);
	public static final ChoreoTraj StartLeftPreload = new ChoreoTraj(
	    "StartLeftPreload",
	    OptionalInt.empty(),
	    1.26025,
	    new Pose2d(3.564, 7.665, Rotation2d.fromRadians(3.138)),
	    new Pose2d(2.523, 6.373, Rotation2d.fromRadians(2.335))
	);
	public static final ChoreoTraj StartMiddleShootMiddle = new ChoreoTraj(
	    "StartMiddleShootMiddle",
	    OptionalInt.empty(),
	    1.4369,
	    new Pose2d(3.584, 3.981, Rotation2d.fromRadians(3.142)),
	    new Pose2d(1.657, 3.989, Rotation2d.fromRadians(3.142))
	);
	public static final ChoreoTraj StartRightOutpost = new ChoreoTraj(
	    "StartRightOutpost",
	    OptionalInt.empty(),
	    4.69972,
	    new Pose2d(3.584, 0.392, Rotation2d.fromRadians(3.142)),
	    new Pose2d(3.375, 2.476, Rotation2d.fromRadians(-2.251))
	);
	public static final ChoreoTraj StartRightOutpost$0 = new ChoreoTraj(
	    "StartRightOutpost",
	    OptionalInt.of(0),
	    2.25797,
	    new Pose2d(3.584, 0.392, Rotation2d.fromRadians(3.142)),
	    new Pose2d(0.419, 0.675, Rotation2d.fromRadians(-3.142))
	);
	public static final ChoreoTraj StartRightOutpost$1 = new ChoreoTraj(
	    "StartRightOutpost",
	    OptionalInt.of(1),
	    2.4417500000000003,
	    new Pose2d(0.419, 0.675, Rotation2d.fromRadians(-3.142)),
	    new Pose2d(3.375, 2.476, Rotation2d.fromRadians(-2.251))
	);
	public static final ChoreoTraj StartRightPreload = new ChoreoTraj(
	    "StartRightPreload",
	    OptionalInt.empty(),
	    1.1373,
	    new Pose2d(3.584, 0.392, Rotation2d.fromRadians(3.142)),
	    new Pose2d(2.675, 1.551, Rotation2d.fromRadians(-2.275))
	);
	public static final ChoreoTraj StartRightPreloadOutpost = new ChoreoTraj(
	    "StartRightPreloadOutpost",
	    OptionalInt.empty(),
	    4.56975,
	    new Pose2d(3.584, 0.392, Rotation2d.fromRadians(3.142)),
	    new Pose2d(2.675, 1.551, Rotation2d.fromRadians(-2.412))
	);
	public static final ChoreoTraj StartRightPreloadOutpost$0 = new ChoreoTraj(
	    "StartRightPreloadOutpost",
	    OptionalInt.of(0),
	    1.0514,
	    new Pose2d(3.584, 0.392, Rotation2d.fromRadians(3.142)),
	    new Pose2d(2.675, 1.551, Rotation2d.fromRadians(-2.412))
	);
	public static final ChoreoTraj StartRightPreloadOutpost$1 = new ChoreoTraj(
	    "StartRightPreloadOutpost",
	    OptionalInt.of(1),
	    1.75918,
	    new Pose2d(2.675, 1.551, Rotation2d.fromRadians(-2.412)),
	    new Pose2d(0.419, 0.675, Rotation2d.fromRadians(-3.142))
	);
	public static final ChoreoTraj StartRightPreloadOutpost$2 = new ChoreoTraj(
	    "StartRightPreloadOutpost",
	    OptionalInt.of(2),
	    1.7591700000000001,
	    new Pose2d(0.419, 0.675, Rotation2d.fromRadians(-3.142)),
	    new Pose2d(2.675, 1.551, Rotation2d.fromRadians(-2.412))
	);
	public static final ChoreoTraj TUNING_RotatedPath_MaxAccel_01rps = new ChoreoTraj(
	    "TUNING_RotatedPath_MaxAccel_01rps",
	    OptionalInt.empty(),
	    6.31111,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj TUNING_RotatedPath_MaxAccel_02rps = new ChoreoTraj(
	    "TUNING_RotatedPath_MaxAccel_02rps",
	    OptionalInt.empty(),
	    3.19437,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj TUNING_RotatedPath_MaxAccel_04rps = new ChoreoTraj(
	    "TUNING_RotatedPath_MaxAccel_04rps",
	    OptionalInt.empty(),
	    2.11659,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj TUNING_RotatedPath_MaxAccel_08rps = new ChoreoTraj(
	    "TUNING_RotatedPath_MaxAccel_08rps",
	    OptionalInt.empty(),
	    2.07422,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj TUNING_RotatedPath_MaxAccel_12rps = new ChoreoTraj(
	    "TUNING_RotatedPath_MaxAccel_12rps",
	    OptionalInt.empty(),
	    3.01396,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj TUNING_RotStrPath_MaxAccel_01rps = new ChoreoTraj(
	    "TUNING_RotStrPath_MaxAccel_01rps",
	    OptionalInt.empty(),
	    6.31135,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj TUNING_RotStrPath_MaxAccel_05rps = new ChoreoTraj(
	    "TUNING_RotStrPath_MaxAccel_05rps",
	    OptionalInt.empty(),
	    4.17067,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj TUNING_RotStrPath_MaxAccel_10rps = new ChoreoTraj(
	    "TUNING_RotStrPath_MaxAccel_10rps",
	    OptionalInt.empty(),
	    2.33954,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj TUNING_RotStrPath_MaxAccel_15rps = new ChoreoTraj(
	    "TUNING_RotStrPath_MaxAccel_15rps",
	    OptionalInt.empty(),
	    2.07556,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj TUNING_StraightPathNAV_MaxAccel_01fps = new ChoreoTraj(
	    "TUNING_StraightPathNAV_MaxAccel_01fps",
	    OptionalInt.empty(),
	    20.05072,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj TUNING_StraightPathNAV_MaxAccel_05fps = new ChoreoTraj(
	    "TUNING_StraightPathNAV_MaxAccel_05fps",
	    OptionalInt.empty(),
	    4.17263,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj TUNING_StraightPathNAV_MaxAccel_10fps = new ChoreoTraj(
	    "TUNING_StraightPathNAV_MaxAccel_10fps",
	    OptionalInt.empty(),
	    4.17153,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj TUNING_StraightPathNAV_MaxAccel_15fps = new ChoreoTraj(
	    "TUNING_StraightPathNAV_MaxAccel_15fps",
	    OptionalInt.empty(),
	    2.07418,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj TUNING_StraightPath_MaxAccel_01fps = new ChoreoTraj(
	    "TUNING_StraightPath_MaxAccel_01fps",
	    OptionalInt.empty(),
	    20.054,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj TUNING_StraightPath_MaxAccel_05fps = new ChoreoTraj(
	    "TUNING_StraightPath_MaxAccel_05fps",
	    OptionalInt.empty(),
	    4.17334,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj TUNING_StraightPath_MaxAccel_10fps = new ChoreoTraj(
	    "TUNING_StraightPath_MaxAccel_10fps",
	    OptionalInt.empty(),
	    2.33971,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj TUNING_StraightPath_MaxAccel_MaxSpeed = new ChoreoTraj(
	    "TUNING_StraightPath_MaxAccel_MaxSpeed",
	    OptionalInt.empty(),
	    1.81238,
	    new Pose2d(0, 0, Rotation2d.fromRadians(0)),
	    new Pose2d(6.096, 0, Rotation2d.fromRadians(0))
	);

    /**
     * A map between trajectory names and their corresponding data.
     * This allows for trajectory data to be looked up with strings during runtime.
     */
    public static final Map<String, ChoreoTraj> ALL_TRAJECTORIES = Map.ofEntries(
    	Map.entry("StartLeftDepot", StartLeftDepot),
		Map.entry("StartLeftDepot$0", StartLeftDepot$0),
		Map.entry("StartLeftDepot$1", StartLeftDepot$1),
		Map.entry("StartLeftPreload", StartLeftPreload),
		Map.entry("StartMiddleShootMiddle", StartMiddleShootMiddle),
		Map.entry("StartRightOutpost", StartRightOutpost),
		Map.entry("StartRightOutpost$0", StartRightOutpost$0),
		Map.entry("StartRightOutpost$1", StartRightOutpost$1),
		Map.entry("StartRightPreload", StartRightPreload),
		Map.entry("StartRightPreloadOutpost", StartRightPreloadOutpost),
		Map.entry("StartRightPreloadOutpost$0", StartRightPreloadOutpost$0),
		Map.entry("StartRightPreloadOutpost$1", StartRightPreloadOutpost$1),
		Map.entry("StartRightPreloadOutpost$2", StartRightPreloadOutpost$2),
		Map.entry("TUNING_RotatedPath_MaxAccel_01rps", TUNING_RotatedPath_MaxAccel_01rps),
		Map.entry("TUNING_RotatedPath_MaxAccel_02rps", TUNING_RotatedPath_MaxAccel_02rps),
		Map.entry("TUNING_RotatedPath_MaxAccel_04rps", TUNING_RotatedPath_MaxAccel_04rps),
		Map.entry("TUNING_RotatedPath_MaxAccel_08rps", TUNING_RotatedPath_MaxAccel_08rps),
		Map.entry("TUNING_RotatedPath_MaxAccel_12rps", TUNING_RotatedPath_MaxAccel_12rps),
		Map.entry("TUNING_RotStrPath_MaxAccel_01rps", TUNING_RotStrPath_MaxAccel_01rps),
		Map.entry("TUNING_RotStrPath_MaxAccel_05rps", TUNING_RotStrPath_MaxAccel_05rps),
		Map.entry("TUNING_RotStrPath_MaxAccel_10rps", TUNING_RotStrPath_MaxAccel_10rps),
		Map.entry("TUNING_RotStrPath_MaxAccel_15rps", TUNING_RotStrPath_MaxAccel_15rps),
		Map.entry("TUNING_StraightPathNAV_MaxAccel_01fps", TUNING_StraightPathNAV_MaxAccel_01fps),
		Map.entry("TUNING_StraightPathNAV_MaxAccel_05fps", TUNING_StraightPathNAV_MaxAccel_05fps),
		Map.entry("TUNING_StraightPathNAV_MaxAccel_10fps", TUNING_StraightPathNAV_MaxAccel_10fps),
		Map.entry("TUNING_StraightPathNAV_MaxAccel_15fps", TUNING_StraightPathNAV_MaxAccel_15fps),
		Map.entry("TUNING_StraightPath_MaxAccel_01fps", TUNING_StraightPath_MaxAccel_01fps),
		Map.entry("TUNING_StraightPath_MaxAccel_05fps", TUNING_StraightPath_MaxAccel_05fps),
		Map.entry("TUNING_StraightPath_MaxAccel_10fps", TUNING_StraightPath_MaxAccel_10fps),
		Map.entry("TUNING_StraightPath_MaxAccel_MaxSpeed", TUNING_StraightPath_MaxAccel_MaxSpeed)
    );

    /**
     * Looks up the ChoreoTraj segment of the given overall ChoreoTraj.
     * WARNING: will raise an exception if not called with a valid segment index.
     */
    public ChoreoTraj segment(int segment) {
        var traj = ChoreoTraj.ALL_TRAJECTORIES.get(this.name + "$" + segment);
        if (traj == null) {
            throw new NullPointerException("Trajectory " + this.name + " does not have segment #" + segment + ".");
        }
        return traj;
    }
    
    // If these methods cause errors because you're not using ChoreoLib,
    // turn off "Include ChoreoLib-specific Helpers" in Choreo's codegen settings.
    /**
     * Load an AutoTrajectory directly from a ChoreoTraj, which may be a segment of a larger trajectory.
     */
    public AutoTrajectory asAutoTraj(AutoRoutine routine) {
        if (this.segment.isPresent()) {
            return routine.trajectory(this.name, this.segment.getAsInt());
        }
        return routine.trajectory(this.name);
    }
}
